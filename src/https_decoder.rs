use byteorder::{BigEndian, ReadBytesExt};
use std::io::prelude::*;
use std::io::{SeekFrom, Cursor};
use std::str;

fn is_valid_packet(packet: &[u8]) -> bool {
    (packet.len() > 10 &&
    packet[0] == 0x16 &&
    packet[1] == 0x03 &&
    packet[2] == 0x01)
}

pub fn get_domain(packet: &[u8]) -> Option<&str> {
    if !is_valid_packet(packet) { return None } 
    let mut reader = Cursor::new(packet);

    // Start by skipping over the handshake header and random data.
    if reader.seek(SeekFrom::Start(43)).is_err() { return None }

    // Session ID
    let session_id_length = reader.read_u8().unwrap_or(0);
    if reader.seek(SeekFrom::Current(session_id_length as i64)).is_err() { return None }

    let cipher_suites_length = reader.read_u16::<BigEndian>().unwrap_or(0);
    if reader.seek(SeekFrom::Current(cipher_suites_length as i64)).is_err() { return None }

    // Skip over the compression methods, plus 2 bytes to get to the first extension.
    let compression_methods_length = reader.read_u8().unwrap_or(0) as usize;
    if reader.seek(SeekFrom::Current((compression_methods_length + 2) as i64)).is_err() { return None }

    // We are now at the extensions field. Read the extensions type.
    let mut extension_type = reader.read_u16::<BigEndian>().unwrap_or(0) as usize;

    // Keep reading over extensions until we find 0x00 (Server Name Indication).
    // It's usually first, but Apple seems to like putting other fields before it.
    while extension_type != 0x00 {
        // Server Session Token.
        if extension_type == 0x23 {
            let session_ticket_length = reader.read_u8().unwrap_or(0) as usize;
            let seek_length = if session_ticket_length == 0 { 1 } else { session_ticket_length };
            if reader.seek(SeekFrom::Current(seek_length as i64)).is_err() { return None }
        }

        extension_type = reader.read_u16::<BigEndian>().unwrap_or(0) as usize;
    }

    // We are now at the beginning of the Server Name Indication extension.
    // Skip over the server_name extension length field.
    if reader.seek(SeekFrom::Current(2 as i64)).is_err() { return None }

    // Skip over the server_name_indication_length field.
    if reader.seek(SeekFrom::Current(2 as i64)).is_err() { return None }

    // Check that the server_name_type is 0x00 (host_name)
    let server_name_type = reader.read_u8().unwrap_or(0) as usize;
    if server_name_type != 0x00 { return None }

    // Find the length of the server_name.
    let server_name_length = reader.read_u16::<BigEndian>().unwrap_or(0) as usize;

    // Get our current position.
    let current_position = (reader.position()) as usize;

    // We now want to read from the start of the server_name field to the end of the
    // server_name field.
    let end_position = current_position + server_name_length as usize;
    let server_name_buf = reader.get_ref();

    // Add a guard here, as reading from an invalid packet will cause a panic.
    if server_name_buf.len() > end_position {
        let server_name = &server_name_buf[current_position.. end_position];

        // Try converting the server_name field into a UTF8 String.
        str::from_utf8(server_name).ok()
    } else {
        None
    }
}

#[test]
fn test_get_domain() {
    let test_packet = vec![
    0x16, // Content-Type: Handshake.
    0x03, 0x01, // Version: TLS 1.0
    0x00, 0xe3, // Length: 227
    0x01, // Handshake Type: Client Hello.
    0x00, 0x00, 0xdf, // Handshake Length: 223
    0x03, 0x03, // Version: TLS 1.2
    0x57, 0x2d, 0xf4, 0x64, 0x93, 0x51, 0x5a, 0x0e, // 32 Bytes of Random data.
    0xd7, 0xfb, 0x39, 0xa2, 0x95, 0x92, 0x7d, 0x33, 
    0xfa, 0xae, 0xea, 0xeb, 0x01, 0x44, 0x02, 0x88, 
    0x4f, 0xf3, 0x5b, 0x9c, 0xf4, 0x73, 0xeb, 0x39, 
    0x00, // Session ID Length
    0x00, 0x6e, // Cipher Suites Length: 110 (Skip forward this amount)
        0x00, 0xff, 0xc0, 0x2c, 0xc0,  // Cipher Suites.
        0x2b, 0xc0, 0x24, 0xc0, 0x23,  // (continued..) 
        0xc0, 0x0a, 0xc0, 0x09, 0xc0, 0x08, 0xc0, 0x30, 
        0xc0, 0x2f, 0xc0, 0x28, 0xc0, 0x27, 0xc0, 0x14, 
        0xc0, 0x13, 0xc0, 0x12, 0xc0, 0x2e, 0xc0, 0x2d, 
        0xc0, 0x26, 0xc0, 0x25, 0xc0, 0x05, 0xc0, 0x04, 
        0xc0, 0x03, 0xc0, 0x32, 0xc0, 0x31, 0xc0, 0x2a, 
        0xc0, 0x29, 0xc0, 0x0f, 0xc0, 0x0e, 0xc0, 0x0d, 
        0x00, 0x9f, 0x00, 0x9e, 0x00, 0x6b, 0x00, 0x67, 
        0x00, 0x39, 0x00, 0x33, 0x00, 0x16, 0x00, 0x9d, 
        0x00, 0x9c, 0x00, 0x3d, 0x00, 0x3c, 0x00, 0x35, 
        0x00, 0x2f, 0x00, 0x0a, 0xc0, 0x07, 0xc0, 0x11, 
        0xc0, 0x02, 0xc0, 0x0c, 0x00, 0x05, 0x00, 0x04, 
        0x00, 0xaf, 0x00, 0xae, 0x00, 0x8d, 0x00, 0x8c, 
        0x00, 0x8a, 0x00, 0x8b, 
    0x01, // Compresion Methods Length: 1 (Skip forward this amount) 
        0x00, // NULL
    0x00, 0x48, // Extensions Length: 72
        0x00, 0x00, // Extension Type: Server Name.
            0x00, 0x13, // Server Name Length: 19 
            0x00, 0x11, // Server Name Indication Length: 17
                0x00, // Server Name Type: host_name (Check this)
                0x00, 0x0e, // Server Name Length: 14 
                0x77, 0x77, 0x77, 0x2e, 0x67, 0x6f, 0x6f, // w w w . g o o
                0x67, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, // g l e . c o m
        // Ignore everything after this.
        0x00, 0x0a, 0x00, 0x08, 0x00, 0x06, 0x00, 0x17, // Eliptic Curves
        0x00, 0x18, 0x00, 0x19, 
            0x00, 0x0b, // EC Points Format
            0x00, 0x02, 0x01, // etc..
        0x00, 0x00, 0x0d, 0x00, 0x0e, 0x00, 0x0c, 0x05, 
        0x01, 0x04, 0x01, 0x02, 0x01, 0x05, 0x03, 0x04, 
        0x03, 0x02, 0x03, 0x00, 0x05, 0x00, 0x05, 0x01, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00];

    let expected_domain = Some("www.google.com");
    assert_eq!(get_domain(&test_packet[..]), expected_domain);
}

#[test]
fn test_get_smoot() {
    let smoot_packet = vec![
        0x16, // Content-Type: Handshake
        0x03, 0x01, // Version: TLS 1.0
        0x00, 0xe3, // Length: 227
        0x01, // Handshake Type: Client Hello.
        0x00, 0x00, 0xdf, // Handshake Length: 223
        0x03, 0x03, // Version: TLS 1.2
        0x57, 0x98, 0x66, 0xe6, // Unix Time: July 27, 2016, 17:46:46
        0xe8, 0x95, 0x67, 0x9d, 0xbb, 0x9e, 0x35, 0xee, // Random Data
        0x82, 0x11, 0x53, 0xca, 0xeb, 0x9b, 0xe8, 0x8d, // (continued..)
        0x43, 0x7f, 0x75, 0x80, 0x02, 0xf4, 0x97, 0x19, 
        0x2a, 0x00, 0x08, 0xa8, 
        0x0e, // Session ID Length: 14
            0x53, 0x45, 0x53, 0x53, 0x49, 0x4f, 0x4e, 0x2d, 0x54, // Session ID: SESSION-T
            0x49, 0x43, 0x4b, 0x45, 0x54,                         // ICKET 
        0x00, 0x2c, // Cipher Suites Length: 44
            0x00, 0xff, 0xc0, 0x2c, 0xc0, 0x2b, 0xc0, 0x24, 0xc0,  // Cipher Suites..
            0x23, 0xc0, 0x0a, 0xc0, 0x09, 0xc0, 0x08, 0xc0, 0x30,  // (continued..)
            0xc0, 0x2f, 0xc0, 0x28, 0xc0, 0x27, 0xc0, 0x14, 0xc0, 
            0x13, 0xc0, 0x12, 0x00, 0x9d, 0x00, 0x9c, 0x00, 0x3d, 
            0x00, 0x3c, 0x00, 0x35, 0x00, 0x2f, 0x00, 0x0a, 
        0x01, // Compression Methods Length: 1
        0x00, // Compression Methods: NULL
        0x00, 0x7c, // Extensions Length: 124
            0x00, 0x23, // Extension Type: SessionTicket TLS
            0x00, // Length: 0
            0x00, // Data: 0
        0x00, 0x00, // Extension Type: Server Name
            0x00, 0x18, // Length: 24
            0x00, 0x16, // Server Name Indication Length: 22
            0x00, 0x00, // Server Name Type: Host Name
            0x13, // Server Name Length: 19
            0x61, 0x70, 0x69, 0x2e, 0x73, 0x6d, 0x6f, 0x6f, // a p i . s m o o
            0x74, 0x2e, 0x61, 0x70, 0x70, 0x6c, 0x65, 0x2e, // t . a p p l e .
            0x63, 0x6f, 0x6d,                               // c o m 
        0x00, 0x0a, 0x00, 0x08, // Rest of packet. 
        0x00, 0x06, 0x00, 0x17, 0x00, 0x18, 0x00, 0x19, 
        0x00, 0x0b, 0x00, 0x02, 0x01, 0x00, 0x00, 0x0d, 
        0x00, 0x0e, 0x00, 0x0c, 0x05, 0x01, 0x04, 0x01, 
        0x02, 0x01, 0x05, 0x03, 0x04, 0x03, 0x02, 0x03, 
        0x33, 0x74, 0x00, 0x00, 0x00, 0x10, 0x00, 0x30, 
        0x00, 0x2e, 0x02, 0x68, 0x32, 0x05, 0x68, 0x32, 
        0x2d, 0x31, 0x36, 0x05, 0x68, 0x32, 0x2d, 0x31, 
        0x35, 0x05, 0x68, 0x32, 0x2d, 0x31, 0x34, 0x08, 
        0x73, 0x70, 0x64, 0x79, 0x2f, 0x33, 0x2e, 0x31, 
        0x06, 0x73, 0x70, 0x64, 0x79, 0x2f, 0x33, 0x08, 
        0x68, 0x74, 0x74, 0x70, 0x2f, 0x31, 0x2e, 0x31
    ];
    let expected_domain = Some("api.smoot.apple.com");
    assert_eq!(get_domain(&smoot_packet[..]), expected_domain);
}

#[test]
fn test_parsing_a_non_handshake_ssl_packet_without_panicing() {
    let garbage_packet = vec![0xc0, 0xff, 0xee, 0x15, 0xf0, 0x0d];
    assert_eq!(get_domain(&garbage_packet[..]), None);

    let non_handshake_ssl = vec![
        0x16, 0x03, 0x03, 0x00, 0x46, 0x10, 0x00, 0x00,
        0x42, 0x41, 0x04, 0x5c, 0xd7, 0x32, 0x4f, 0x04, 0xfd, 0x10, 0x0d, 0xee, 0x9d, 0x36, 0xa3, 0x0a,
        0xc1, 0xa4, 0x87, 0xae, 0xd6, 0xe7, 0x15, 0xb6, 0x46, 0xcb, 0xd3, 0xa0, 0x40, 0x71, 0x5e, 0x46,
        0xa2, 0xa8, 0x18, 0x57, 0x00, 0x37, 0x3d, 0x81, 0x0b, 0x90, 0xd3, 0xd4, 0x96, 0x11, 0x3a, 0x77,
        0xbf, 0x3a, 0x90, 0xb3, 0xf7, 0x14, 0xbd, 0x39, 0xda, 0x66, 0xfb, 0xa4, 0x00, 0x28, 0x28, 0xd1,
        0x1f, 0x36, 0xc3, 0x14, 0x03, 0x03, 0x00, 0x01, 0x01, 0x16, 0x03, 0x03, 0x00, 0x20, 0x79, 0x3a,
        0x62, 0x21, 0x82, 0xe9, 0x0d, 0xe0, 0x89, 0xf7, 0x68, 0x09, 0xbb, 0xf6, 0x10, 0xf9, 0x12, 0xaa,
        0xed, 0x6f, 0x05, 0x13, 0xe9, 0x0c, 0x5f, 0xd8, 0x0e, 0x64, 0x35, 0x31, 0x65, 0xa7,
    ];
    assert_eq!(get_domain(&non_handshake_ssl[..]), None);
}
