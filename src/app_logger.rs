use std::net::Ipv4Addr;
use std::io::Write;
use std::collections::HashMap;
use std::fs::OpenOptions;
use http_decoder;
use https_decoder;
use chrono::Local;
use mio::Sender;
use tunnel::TraxiMessage;

pub type DomainMap = HashMap<Ipv4Addr, String>;

#[derive(Debug)]
pub struct AppLogger {
    pub log_file_path: String,
    pub uuid: Option<String>,
    pub app_id: Option<String>,
    pub destination: String,
}

impl AppLogger {
    pub fn new(log_file_path: String, destination: Ipv4Addr) -> AppLogger {
        AppLogger {
            log_file_path: log_file_path,
            destination: format!("{}", destination),
            uuid: None,
            app_id: None,
        }
    }

    pub fn set_domain(&mut self, payload: &Vec<u8>, port: u16) {
        let domain = match port {
            80 => http_decoder::get_domain(&payload),
            443 => https_decoder::get_domain(&payload),
            _ => None
        };

        if let Some(domain) = domain {
            self.destination = domain.to_string()
        }
    }

    pub fn set_app_id(&mut self, payload: &Vec<u8>) {
        // Only proceed if the App ID isn't already set.
        if self.app_id != None { return; }

        if let Some(user_agent) = http_decoder::get_user_agent(&payload) {
            self.app_id = Some(user_agent.to_string())
        }
    }

    pub fn log_response(&mut self, response_size: usize, sender: &Sender<TraxiMessage>) {
        // We only log if we've transferred more than 1 byte.
        if response_size < 1 {
            return;
        }

        let default = "".to_string();
        let app_id_string = self.app_id.as_ref().unwrap_or(&default);

        let default = "traxi".to_string();
        let uuid = self.uuid.as_ref().unwrap_or(&default);

        let now = Local::now();
        let today = now.format("%Y-%m-%d");
        let file_name = format!("{}-{}", today, uuid.clone());

        let timestamp = now.to_rfc3339();

        // Build the log string.
        let log_string = format!("{}\t{}\t{}\t{}\n",
                                timestamp,
                                self.destination,
                                response_size,
                                app_id_string);

        // Write the log.
        let ref log_file_path = format!("{}/{}.log", self.log_file_path, file_name);
        let log_writer = OpenOptions::new().create(true).append(true).open(log_file_path);

        if log_writer.is_err() {
            error!("APP_LOGGER| Unable to open file path {}: {:?}", log_file_path, log_writer);
            return;
        }

        let mut log_writer = log_writer.unwrap();
        let log_bytes = log_string.as_bytes();
        
        match log_writer.write(log_bytes).and_then(|_| log_writer.flush() ) {
            Ok(()) => debug!("Successfully wrote {} to log file", log_string),
            Err(e) => error!("Unable to write to log file: {:?}", e)
        };

        // Only log requests that have an app ID
        if let Some(_) = self.app_id {
            let log_message = TraxiMessage::AppendToLogQueue((uuid.clone(), log_bytes.to_vec()));
            drop(sender.send(log_message)); // Drop here as send should NEVER fail.
        }
    }
}

#[cfg(test)]
mod tests {
    extern crate log4rs;

    use super::*;
    use std::fs;
    use std::fs::File;
    use std::io::Read;
    use std::net::Ipv4Addr;
    use chrono::{Local};
    use mio::{EventLoop, Sender};
    use test_utils::FakeEnvironment;
    use tunnel::{TraxiMessage, TraxiTunnel, Environment};

    #[test]
    fn test_log_ip_address() {
        let test_ip = Ipv4Addr::new(192,168,1,1);
        let test_ip_str = "192.168.1.1";
        let test_uuid = "test_log_ip_address";
        let today = Local::now().format("%Y-%m-%d");
        let test_log_path = &format!("{}-{}.log", today, test_uuid);
        let mut app_logger = AppLogger::new("./".to_string(), test_ip);

        app_logger.uuid = Some(test_uuid.to_string());
        app_logger.log_response(9001, &test_channel::<FakeEnvironment>());

        let mut log_string = String::new();
        File::open(test_log_path).expect("Couldn't open file").read_to_string(&mut log_string).expect("Couldn't parse string");
        assert!(log_string.contains(test_ip_str));

        fs::remove_file(test_log_path).expect("Couldn't remove file");
    }

    #[test]
    fn test_log_payload() {
        // Test Variables
        let test_uuid = "log_payload";
        let today = Local::now().format("%Y-%m-%d");
        let test_ip = Ipv4Addr::new(192,168,1,1);
        let test_log_path = &format!("{}-{}.log", today, test_uuid);

        // Build App Logger
        let mut app_logger = AppLogger::new("./".to_string(), test_ip);
        app_logger.uuid = Some(test_uuid.to_string());

        // Log!
        app_logger.log_response(9001, &test_channel::<FakeEnvironment>());

        let mut log_string = String::new();
        File::open(test_log_path).expect("Couldn't open file").read_to_string(&mut log_string).expect("Couldn't parse string");

        assert!(log_string.contains("\t9001"));

        fs::remove_file(test_log_path).unwrap();
    }

    #[test]
    fn test_log_response_length() {
        drop(log4rs::init_file("./config/test.yaml", Default::default()));

        // Test Variables
        let test_uuid = "log_response_length";
        let today = Local::now().format("%Y-%m-%d");
        let test_log_path = &format!("{}-{}.log", today, test_uuid);
        let test_ip = Ipv4Addr::new(192,168,1,1);

        // Build up app_logger
        let mut app_logger = AppLogger::new("./".to_string(), test_ip);
        app_logger.uuid = Some(test_uuid.to_string());

        // Log response.
        app_logger.log_response(9001, &test_channel::<FakeEnvironment>());

        let mut log_string = String::new();
        File::open(test_log_path).expect("Couldn't open file").read_to_string(&mut log_string).expect("Couldn't parse string");

        assert!(log_string.contains("\t9001"));

        fs::remove_file(test_log_path).unwrap();
    }

    #[test]
    fn test_log_http_with_user_agent() {
        let test_ip = Ipv4Addr::new(192,168,1,1);
		let http_request_with_user_agent = vec![
			0x47, 0x45, 0x54, 0x20, 0x2f, 0x72, 0x65, 0x73, 
			0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x2f, 0x63, 
			0x73, 0x73, 0x2f, 0x6d, 0x61, 0x73, 0x74, 0x68, 
			0x65, 0x61, 0x64, 0x73, 0x2f, 0x31, 0x2e, 0x33, 
			0x2e, 0x31, 0x36, 0x2f, 0x73, 0x6b, 0x69, 0x6e, 
			0x2d, 0x74, 0x68, 0x65, 0x61, 0x67, 0x65, 0x2e, 
			0x63, 0x73, 0x73, 0x20, 0x48, 0x54, 0x54, 0x50, 
			0x2f, 0x31, 0x2e, 0x31, 0x0d, 0x0a, 0x48, 0x6f, 
			0x73, 0x74, 0x3a, 0x20, 0x77, 0x77, 0x77, 0x2e, 
			0x66, 0x61, 0x69, 0x72, 0x66, 0x61, 0x78, 0x73, 
			0x74, 0x61, 0x74, 0x69, 0x63, 0x2e, 0x63, 0x6f, 
			0x6d, 0x2e, 0x61, 0x75, 0x0d, 0x0a, 0x43, 0x6f, 
			0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 
			0x3a, 0x20, 0x6b, 0x65, 0x65, 0x70, 0x2d, 0x61, 
			0x6c, 0x69, 0x76, 0x65, 0x0d, 0x0a, 0x55, 0x73, 
			0x65, 0x72, 0x2d, 0x41, 0x67, 0x65, 0x6e, 0x74, 
			0x3a, 0x20, 0x4d, 0x6f, 0x7a, 0x69, 0x6c, 0x6c, 
			0x61, 0x2f, 0x35, 0x2e, 0x30, 0x20, 0x28, 0x4d, 
			0x61, 0x63, 0x69, 0x6e, 0x74, 0x6f, 0x73, 0x68, 
			0x3b, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x6c, 0x20, 
			0x4d, 0x61, 0x63, 0x20, 0x4f, 0x53, 0x20, 0x58, 
			0x20, 0x31, 0x30, 0x5f, 0x31, 0x32, 0x5f, 0x31, 
			0x29, 0x20, 0x41, 0x70, 0x70, 0x6c, 0x65, 0x57, 
			0x65, 0x62, 0x4b, 0x69, 0x74, 0x2f, 0x35, 0x33, 
			0x37, 0x2e, 0x33, 0x36, 0x20, 0x28, 0x4b, 0x48, 
			0x54, 0x4d, 0x4c, 0x2c, 0x20, 0x6c, 0x69, 0x6b, 
			0x65, 0x20, 0x47, 0x65, 0x63, 0x6b, 0x6f, 0x29, 
			0x20, 0x43, 0x68, 0x72, 0x6f, 0x6d, 0x65, 0x2f, 
			0x35, 0x34, 0x2e, 0x30, 0x2e, 0x32, 0x38, 0x34, 
			0x30, 0x2e, 0x39, 0x38, 0x20, 0x53, 0x61, 0x66, 
			0x61, 0x72, 0x69, 0x2f, 0x35, 0x33, 0x37, 0x2e, 
			0x33, 0x36, 0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65, 
			0x70, 0x74, 0x3a, 0x20, 0x74, 0x65, 0x78, 0x74, 
			0x2f, 0x63, 0x73, 0x73, 0x2c, 0x2a, 0x2f, 0x2a, 
			0x3b, 0x71, 0x3d, 0x30, 0x2e, 0x31, 0x0d, 0x0a, 
			0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x72, 0x3a, 
			0x20, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 
			0x77, 0x77, 0x77, 0x2e, 0x74, 0x68, 0x65, 0x61, 
			0x67, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 
			0x75, 0x2f, 0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65, 
			0x70, 0x74, 0x2d, 0x45, 0x6e, 0x63, 0x6f, 0x64, 
			0x69, 0x6e, 0x67, 0x3a, 0x20, 0x67, 0x7a, 0x69, 
			0x70, 0x2c, 0x20, 0x64, 0x65, 0x66, 0x6c, 0x61, 
			0x74, 0x65, 0x2c, 0x20, 0x73, 0x64, 0x63, 0x68, 
			0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 
			0x2d, 0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 
			0x65, 0x3a, 0x20, 0x65, 0x6e, 0x2d, 0x47, 0x42, 
			0x2c, 0x65, 0x6e, 0x2d, 0x55, 0x53, 0x3b, 0x71, 
			0x3d, 0x30, 0x2e, 0x38, 0x2c, 0x65, 0x6e, 0x3b, 
			0x71, 0x3d, 0x30, 0x2e, 0x36, 0x0d, 0x0a, 0x0d, 
			0x0a
		];

        let expected_domain = "www.fairfaxstatic.com.au";
        let expected_app_id = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.98 Safari/537.36";
        let test_uuid = "test_log_http";
        let today = Local::now().format("%Y-%m-%d");
        let test_log_path = &format!("{}-{}.log", today, test_uuid);
        let mut app_logger = AppLogger::new("./".to_string(), test_ip);

        app_logger.set_domain(&http_request_with_user_agent, 80);
		app_logger.set_app_id(&http_request_with_user_agent);
        app_logger.uuid = Some(test_uuid.to_string());

        app_logger.log_response(9001, &test_channel::<FakeEnvironment>());

        let mut log_string = String::new();
        File::open(test_log_path).unwrap().read_to_string(&mut log_string).unwrap();
        assert!(log_string.contains(expected_domain));
        assert!(log_string.contains(expected_app_id));

        fs::remove_file(test_log_path).unwrap();
    }

    #[test]
    fn test_log_https_domain() {
        let test_ip = Ipv4Addr::new(192,168,1,1);
        let test_uuid = "test_log_https_domain";
        let today = Local::now().format("%Y-%m-%d");
        let test_log_path = &format!("{}-{}.log", today, test_uuid);

        let mut app_logger = AppLogger::new("./".to_string(), test_ip);

        app_logger.uuid = Some(test_uuid.to_string());

        let expected_domain = "api.smoot.apple.com";

        let https_request = vec![
            0x16, 0x03, 0x01, 0x00, 0xe3, 0x01, 0x00, 0x00,
            0xdf, 0x03, 0x03, 0x57, 0x98, 0x66, 0xe6, 0xe8,
            0x95, 0x67, 0x9d, 0xbb, 0x9e, 0x35, 0xee, 0x82,
            0x11, 0x53, 0xca, 0xeb, 0x9b, 0xe8, 0x8d, 0x43,
            0x7f, 0x75, 0x80, 0x02, 0xf4, 0x97, 0x19, 0x2a,
            0x00, 0x08, 0xa8, 0x0e, 0x53, 0x45, 0x53, 0x53,
            0x49, 0x4f, 0x4e, 0x2d, 0x54, 0x49, 0x43, 0x4b,
            0x45, 0x54, 0x00, 0x2c, 0x00, 0xff, 0xc0, 0x2c,
            0xc0, 0x2b, 0xc0, 0x24, 0xc0, 0x23, 0xc0, 0x0a,
            0xc0, 0x09, 0xc0, 0x08, 0xc0, 0x30, 0xc0, 0x2f,
            0xc0, 0x28, 0xc0, 0x27, 0xc0, 0x14, 0xc0, 0x13,
            0xc0, 0x12, 0x00, 0x9d, 0x00, 0x9c, 0x00, 0x3d,
            0x00, 0x3c, 0x00, 0x35, 0x00, 0x2f, 0x00, 0x0a,
            0x01, 0x00, 0x00, 0x7c, 0x00, 0x23, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x18, 0x00, 0x16, 0x00, 0x00,
            0x13, 0x61, 0x70, 0x69, 0x2e, 0x73, 0x6d, 0x6f,
            0x6f, 0x74, 0x2e, 0x61, 0x70, 0x70, 0x6c, 0x65,
            0x2e, 0x63, 0x6f, 0x6d, 0x00, 0x0a, 0x00, 0x08,
            0x00, 0x06, 0x00, 0x17, 0x00, 0x18, 0x00, 0x19,
            0x00, 0x0b, 0x00, 0x02, 0x01, 0x00, 0x00, 0x0d,
            0x00, 0x0e, 0x00, 0x0c, 0x05, 0x01, 0x04, 0x01,
            0x02, 0x01, 0x05, 0x03, 0x04, 0x03, 0x02, 0x03,
            0x33, 0x74, 0x00, 0x00, 0x00, 0x10, 0x00, 0x30,
            0x00, 0x2e, 0x02, 0x68, 0x32, 0x05, 0x68, 0x32,
            0x2d, 0x31, 0x36, 0x05, 0x68, 0x32, 0x2d, 0x31,
            0x35, 0x05, 0x68, 0x32, 0x2d, 0x31, 0x34, 0x08,
            0x73, 0x70, 0x64, 0x79, 0x2f, 0x33, 0x2e, 0x31,
            0x06, 0x73, 0x70, 0x64, 0x79, 0x2f, 0x33, 0x08,
            0x68, 0x74, 0x74, 0x70, 0x2f, 0x31, 0x2e, 0x31
        ];

        app_logger.set_domain(&https_request, 443);
        app_logger.log_response(9001, &test_channel::<FakeEnvironment>());

        let mut log_string = String::new();
        File::open(test_log_path).unwrap().read_to_string(&mut log_string).unwrap();

        assert!(log_string.contains(expected_domain));
        fs::remove_file(test_log_path).unwrap();
    }

    fn test_channel<E: Environment>() -> Sender<TraxiMessage> {
        let event_loop: EventLoop<TraxiTunnel<E>> = EventLoop::new().unwrap();
        event_loop.channel()
    }
}
