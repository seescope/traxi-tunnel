use std::net::Ipv4Addr;
use std::collections::HashMap;
use http_decoder;
use https_decoder;
use chrono::Local;
use mio::Sender;
use tunnel::TraxiMessage;

pub type DomainMap = HashMap<Ipv4Addr, String>;

#[derive(Debug)]
pub struct AppLogger {
    pub log_file_path: String,
    pub uuid: Option<String>,
    pub app_id: Option<String>,
    pub destination: String,
}

impl AppLogger {
    pub fn new(log_file_path: String, destination: Ipv4Addr) -> AppLogger {
        AppLogger {
            log_file_path: log_file_path,
            destination: format!("{}", destination),
            uuid: None,
            app_id: None,
        }
    }

    pub fn set_domain(&mut self, payload: &Vec<u8>, port: u16) {
        let domain = match port {
            80 => http_decoder::get_domain(&payload),
            443 => https_decoder::get_domain(&payload),
            _ => None
        };

        if let Some(domain) = domain {
            self.destination = domain.to_string()
        }
    }

    pub fn set_app_id(&mut self, payload: &Vec<u8>) {
        // Only proceed if the App ID isn't already set.
        if self.app_id != None { return; }

        if let Some(user_agent) = http_decoder::get_user_agent(&payload) {
            self.app_id = Some(user_agent.to_string())
        }
    }

    pub fn log_response(&mut self, response_size: usize, sender: &Sender<TraxiMessage>) {
        // We only log if we've transferred more than 1 byte.
        if response_size < 1 {
            return;
        }

        let default_app_id = "".to_string();
        let app_id_string = self.app_id.as_ref().unwrap_or(&default_app_id);

        let default_uuid = "traxi".to_string();
        let uuid = self.uuid.as_ref().unwrap_or(&default_uuid);

        let now = Local::now();
        let timestamp = now.to_rfc3339();

        // Build the log string.
        let log_string = format!("{}\t{}\t{}\t{}\n",
                                timestamp,
                                self.destination,
                                response_size,
                                app_id_string);

        let log_bytes = log_string.as_bytes();

        // Only log requests that have an app ID
        if let Some(_) = self.app_id {
            let log_message = TraxiMessage::AppendToLogQueue((uuid.clone(), log_bytes.to_vec()));
            drop(sender.send(log_message)); // Drop here as send should NEVER fail.
        }
    }
}

#[cfg(test)]
mod tests {
    extern crate log4rs;

    use super::*;
    use std::net::Ipv4Addr;
    use mio::EventLoop;
    use mio::Handler;
    use tunnel::{TraxiMessage};

    struct TestHandler {
        ReceivedUUID: String,
        ReceivedLog: String,
    }

    impl TestHandler {
        fn new() -> TestHandler {
            TestHandler {
                ReceivedUUID: "".to_string(),
                ReceivedLog: "".to_string(),
            }
        }
    }

    impl Handler for TestHandler {
        type Timeout = ();
        type Message = TraxiMessage;

        fn notify(&mut self, _: &mut EventLoop<TestHandler>, msg: TraxiMessage) {
            match msg {
                TraxiMessage::AppendToLogQueue((uuid, log_vector)) => {
                    self.ReceivedUUID = uuid.clone();
                    self.ReceivedLog = String::from_utf8(log_vector).unwrap().clone();

                    println!("Got log {}", self.ReceivedLog)
                }
                _ => {}
            }
        }
    }

    #[test]
    fn test_log_http_with_user_agent() {
        let test_ip = Ipv4Addr::new(192,168,1,1);
		let http_request_with_user_agent = vec![
			0x47, 0x45, 0x54, 0x20, 0x2f, 0x72, 0x65, 0x73,
			0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x2f, 0x63,
			0x73, 0x73, 0x2f, 0x6d, 0x61, 0x73, 0x74, 0x68,
			0x65, 0x61, 0x64, 0x73, 0x2f, 0x31, 0x2e, 0x33,
			0x2e, 0x31, 0x36, 0x2f, 0x73, 0x6b, 0x69, 0x6e,
			0x2d, 0x74, 0x68, 0x65, 0x61, 0x67, 0x65, 0x2e,
			0x63, 0x73, 0x73, 0x20, 0x48, 0x54, 0x54, 0x50,
			0x2f, 0x31, 0x2e, 0x31, 0x0d, 0x0a, 0x48, 0x6f,
			0x73, 0x74, 0x3a, 0x20, 0x77, 0x77, 0x77, 0x2e,
			0x66, 0x61, 0x69, 0x72, 0x66, 0x61, 0x78, 0x73,
			0x74, 0x61, 0x74, 0x69, 0x63, 0x2e, 0x63, 0x6f,
			0x6d, 0x2e, 0x61, 0x75, 0x0d, 0x0a, 0x43, 0x6f,
			0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
			0x3a, 0x20, 0x6b, 0x65, 0x65, 0x70, 0x2d, 0x61,
			0x6c, 0x69, 0x76, 0x65, 0x0d, 0x0a, 0x55, 0x73,
			0x65, 0x72, 0x2d, 0x41, 0x67, 0x65, 0x6e, 0x74,
			0x3a, 0x20, 0x4d, 0x6f, 0x7a, 0x69, 0x6c, 0x6c,
			0x61, 0x2f, 0x35, 0x2e, 0x30, 0x20, 0x28, 0x4d,
			0x61, 0x63, 0x69, 0x6e, 0x74, 0x6f, 0x73, 0x68,
			0x3b, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x6c, 0x20,
			0x4d, 0x61, 0x63, 0x20, 0x4f, 0x53, 0x20, 0x58,
			0x20, 0x31, 0x30, 0x5f, 0x31, 0x32, 0x5f, 0x31,
			0x29, 0x20, 0x41, 0x70, 0x70, 0x6c, 0x65, 0x57,
			0x65, 0x62, 0x4b, 0x69, 0x74, 0x2f, 0x35, 0x33,
			0x37, 0x2e, 0x33, 0x36, 0x20, 0x28, 0x4b, 0x48,
			0x54, 0x4d, 0x4c, 0x2c, 0x20, 0x6c, 0x69, 0x6b,
			0x65, 0x20, 0x47, 0x65, 0x63, 0x6b, 0x6f, 0x29,
			0x20, 0x43, 0x68, 0x72, 0x6f, 0x6d, 0x65, 0x2f,
			0x35, 0x34, 0x2e, 0x30, 0x2e, 0x32, 0x38, 0x34,
			0x30, 0x2e, 0x39, 0x38, 0x20, 0x53, 0x61, 0x66,
			0x61, 0x72, 0x69, 0x2f, 0x35, 0x33, 0x37, 0x2e,
			0x33, 0x36, 0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65,
			0x70, 0x74, 0x3a, 0x20, 0x74, 0x65, 0x78, 0x74,
			0x2f, 0x63, 0x73, 0x73, 0x2c, 0x2a, 0x2f, 0x2a,
			0x3b, 0x71, 0x3d, 0x30, 0x2e, 0x31, 0x0d, 0x0a,
			0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x72, 0x3a,
			0x20, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f,
			0x77, 0x77, 0x77, 0x2e, 0x74, 0x68, 0x65, 0x61,
			0x67, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
			0x75, 0x2f, 0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65,
			0x70, 0x74, 0x2d, 0x45, 0x6e, 0x63, 0x6f, 0x64,
			0x69, 0x6e, 0x67, 0x3a, 0x20, 0x67, 0x7a, 0x69,
			0x70, 0x2c, 0x20, 0x64, 0x65, 0x66, 0x6c, 0x61,
			0x74, 0x65, 0x2c, 0x20, 0x73, 0x64, 0x63, 0x68,
			0x0d, 0x0a, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74,
			0x2d, 0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
			0x65, 0x3a, 0x20, 0x65, 0x6e, 0x2d, 0x47, 0x42,
			0x2c, 0x65, 0x6e, 0x2d, 0x55, 0x53, 0x3b, 0x71,
			0x3d, 0x30, 0x2e, 0x38, 0x2c, 0x65, 0x6e, 0x3b,
			0x71, 0x3d, 0x30, 0x2e, 0x36, 0x0d, 0x0a, 0x0d,
			0x0a
		];

        let expected_domain = "www.fairfaxstatic.com.au";
        let expected_app_id = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.98 Safari/537.36";
        let test_uuid = "test_log_http";
        let mut app_logger = AppLogger::new("./".to_string(), test_ip);

        app_logger.set_domain(&http_request_with_user_agent, 80);
		app_logger.set_app_id(&http_request_with_user_agent);
        app_logger.uuid = Some(test_uuid.to_string());


        let (log_string, uuid) = test_app_logger(&mut app_logger);
        assert!(log_string.contains(expected_domain));
        assert!(log_string.contains(expected_app_id));
        assert!(uuid == test_uuid);
    }

    // Test Helpers

    fn test_app_logger(app_logger: &mut AppLogger) -> (String, String) {
        let mut event_loop = test_event_loop();
        let mut test_handler = TestHandler::new();
        app_logger.log_response(9001, &event_loop.channel());
        {
            drop(event_loop.run_once(&mut test_handler, None));
        }

        (test_handler.ReceivedLog.clone(), test_handler.ReceivedUUID.clone())
    }

    fn test_event_loop() -> EventLoop<TestHandler> {
        EventLoop::new().unwrap()
    }
}
